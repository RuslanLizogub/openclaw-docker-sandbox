diff --git a/src/agents/tools/browser-tool.node-fallback.test.ts b/src/agents/tools/browser-tool.node-fallback.test.ts
new file mode 100644
--- /dev/null
+++ b/src/agents/tools/browser-tool.node-fallback.test.ts
@@ -0,0 +1,135 @@
+import { afterEach, describe, expect, it, vi } from "vitest";
+
+const browserClientMocks = vi.hoisted(() => ({
+  browserCloseTab: vi.fn(async () => ({})),
+  browserFocusTab: vi.fn(async () => ({})),
+  browserOpenTab: vi.fn(async () => ({})),
+  browserProfiles: vi.fn(async () => []),
+  browserSnapshot: vi.fn(async () => ({
+    ok: true,
+    format: "ai",
+    targetId: "t1",
+    url: "https://example.com",
+    snapshot: "ok",
+  })),
+  browserStart: vi.fn(async () => ({})),
+  browserStatus: vi.fn(async () => ({
+    ok: true,
+    running: true,
+    pid: 1,
+    cdpPort: 18792,
+    cdpUrl: "http://127.0.0.1:18792",
+  })),
+  browserStop: vi.fn(async () => ({})),
+  browserTabs: vi.fn(async () => []),
+}));
+vi.mock("../../browser/client.js", () => browserClientMocks);
+
+const browserActionsMocks = vi.hoisted(() => ({
+  browserAct: vi.fn(async () => ({ ok: true })),
+  browserArmDialog: vi.fn(async () => ({ ok: true })),
+  browserArmFileChooser: vi.fn(async () => ({ ok: true })),
+  browserConsoleMessages: vi.fn(async () => ({
+    ok: true,
+    targetId: "t1",
+    messages: [],
+  })),
+  browserNavigate: vi.fn(async () => ({ ok: true })),
+  browserPdfSave: vi.fn(async () => ({ ok: true, path: "/tmp/test.pdf" })),
+  browserScreenshotAction: vi.fn(async () => ({ ok: true, path: "/tmp/test.png" })),
+}));
+vi.mock("../../browser/client-actions.js", () => browserActionsMocks);
+
+const browserConfigMocks = vi.hoisted(() => ({
+  resolveBrowserConfig: vi.fn(() => ({
+    enabled: true,
+    controlPort: 18791,
+  })),
+}));
+vi.mock("../../browser/config.js", () => browserConfigMocks);
+
+const nodesUtilsMocks = vi.hoisted(() => ({
+  listNodes: vi.fn(async () => []),
+}));
+vi.mock("./nodes-utils.js", async () => {
+  const actual = await vi.importActual<typeof import("./nodes-utils.js")>("./nodes-utils.js");
+  return {
+    ...actual,
+    listNodes: nodesUtilsMocks.listNodes,
+  };
+});
+
+const gatewayMocks = vi.hoisted(() => ({
+  callGatewayTool: vi.fn(async () => ({
+    ok: true,
+    payload: { result: { ok: true, running: true } },
+  })),
+}));
+vi.mock("./gateway.js", () => gatewayMocks);
+
+const configMocks = vi.hoisted(() => ({
+  loadConfig: vi.fn(() => ({ browser: {} })),
+}));
+vi.mock("../../config/config.js", () => configMocks);
+
+const toolCommonMocks = vi.hoisted(() => ({
+  imageResultFromFile: vi.fn(),
+}));
+vi.mock("./common.js", async () => {
+  const actual = await vi.importActual<typeof import("./common.js")>("./common.js");
+  return {
+    ...actual,
+    imageResultFromFile: toolCommonMocks.imageResultFromFile,
+  };
+});
+
+import { createBrowserTool } from "./browser-tool.js";
+
+describe("browser tool node target fallback", () => {
+  afterEach(() => {
+    vi.clearAllMocks();
+    configMocks.loadConfig.mockReturnValue({ browser: {} });
+    nodesUtilsMocks.listNodes.mockResolvedValue([]);
+  });
+
+  it("falls back to local browser when target=node but no node is connected", async () => {
+    nodesUtilsMocks.listNodes.mockResolvedValue([]);
+    const tool = createBrowserTool();
+    await tool.execute?.(null, { action: "status", target: "node" });
+
+    expect(browserClientMocks.browserStatus).toHaveBeenCalledWith(
+      undefined,
+      expect.objectContaining({ profile: undefined }),
+    );
+    expect(gatewayMocks.callGatewayTool).not.toHaveBeenCalled();
+  });
+
+  it("keeps explicit node pin strict when node id is requested", async () => {
+    nodesUtilsMocks.listNodes.mockResolvedValue([]);
+    const tool = createBrowserTool();
+
+    await expect(
+      tool.execute?.(null, {
+        action: "status",
+        target: "node",
+        node: "node-1",
+      }),
+    ).rejects.toThrow("No connected browser-capable nodes.");
+
+    expect(browserClientMocks.browserStatus).not.toHaveBeenCalled();
+  });
+});

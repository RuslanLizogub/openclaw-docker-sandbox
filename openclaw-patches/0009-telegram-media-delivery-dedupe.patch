diff --git a/src/telegram/bot/delivery.test.ts b/src/telegram/bot/delivery.test.ts
index bb4eebb..d049ace 100644
--- a/src/telegram/bot/delivery.test.ts
+++ b/src/telegram/bot/delivery.test.ts
@@ -1,6 +1,6 @@
 import type { Bot } from "grammy";
 import { beforeEach, describe, expect, it, vi } from "vitest";
-import { deliverReplies } from "./delivery.js";
+import { __resetDeliveryMediaDedupeForTests, deliverReplies } from "./delivery.js";
 
 const loadWebMedia = vi.fn();
 
@@ -22,6 +22,7 @@ vi.mock("grammy", () => ({
 
 describe("deliverReplies", () => {
   beforeEach(() => {
+    __resetDeliveryMediaDedupeForTests();
     loadWebMedia.mockReset();
   });
 
@@ -144,6 +145,102 @@ describe("deliverReplies", () => {
     expect(sendDocument).toHaveBeenCalledTimes(1);
   });
 
+  it("deduplicates identical media URLs in a single reply", async () => {
+    const runtime = { error: vi.fn(), log: vi.fn() };
+    const sendPhoto = vi.fn().mockResolvedValue({
+      message_id: 14,
+      chat: { id: "123" },
+    });
+    const bot = { api: { sendPhoto } } as unknown as Bot;
+
+    loadWebMedia.mockResolvedValue({
+      buffer: Buffer.from("image"),
+      contentType: "image/jpeg",
+      fileName: "photo.jpg",
+    });
+
+    await deliverReplies({
+      replies: [{ mediaUrls: ["/tmp/screenshot.png", "/tmp/screenshot.png"] }],
+      chatId: "123",
+      token: "tok",
+      runtime,
+      bot,
+      replyToMode: "off",
+      textLimit: 4000,
+    });
+
+    expect(loadWebMedia).toHaveBeenCalledTimes(1);
+    expect(sendPhoto).toHaveBeenCalledTimes(1);
+  });
+
+  it("deduplicates same local media across replies (path + file URL)", async () => {
+    const runtime = { error: vi.fn(), log: vi.fn() };
+    const sendPhoto = vi.fn().mockResolvedValue({
+      message_id: 15,
+      chat: { id: "123" },
+    });
+    const bot = { api: { sendPhoto } } as unknown as Bot;
+
+    loadWebMedia.mockResolvedValue({
+      buffer: Buffer.from("image"),
+      contentType: "image/jpeg",
+      fileName: "photo.jpg",
+    });
+
+    await deliverReplies({
+      replies: [
+        { mediaUrl: "/tmp/screenshot.png" },
+        { mediaUrl: "file:///tmp/screenshot.png" },
+      ],
+      chatId: "123",
+      token: "tok",
+      runtime,
+      bot,
+      replyToMode: "off",
+      textLimit: 4000,
+    });
+
+    expect(loadWebMedia).toHaveBeenCalledTimes(1);
+    expect(sendPhoto).toHaveBeenCalledTimes(1);
+    expect(runtime.error).not.toHaveBeenCalled();
+  });
+
+  it("does not resend identical media across repeated delivery calls for the same reply target", async () => {
+    const runtime = { error: vi.fn(), log: vi.fn() };
+    const sendPhoto = vi.fn().mockResolvedValue({
+      message_id: 16,
+      chat: { id: "123" },
+    });
+    const bot = { api: { sendPhoto } } as unknown as Bot;
+
+    loadWebMedia.mockResolvedValue({
+      buffer: Buffer.from("image"),
+      contentType: "image/jpeg",
+      fileName: "photo.jpg",
+    });
+
+    const common = {
+      chatId: "123",
+      token: "tok",
+      runtime,
+      bot,
+      replyToMode: "all" as const,
+      textLimit: 4000,
+    };
+
+    await deliverReplies({
+      ...common,
+      replies: [{ mediaUrl: "/tmp/screenshot.png", replyToId: "500" }],
+    });
+    await deliverReplies({
+      ...common,
+      replies: [{ mediaUrl: "file:///tmp/screenshot.png", replyToId: "500" }],
+    });
+
+    expect(loadWebMedia).toHaveBeenCalledTimes(1);
+    expect(sendPhoto).toHaveBeenCalledTimes(1);
+  });
+
+  it("does not resend identical media across repeated delivery calls when replyTo mode is off", async () => {
+    const runtime = { error: vi.fn(), log: vi.fn() };
+    const sendPhoto = vi.fn().mockResolvedValue({
+      message_id: 17,
+      chat: { id: "123" },
+    });
+    const bot = { api: { sendPhoto } } as unknown as Bot;
+
+    loadWebMedia.mockResolvedValue({
+      buffer: Buffer.from("image"),
+      contentType: "image/jpeg",
+      fileName: "photo.jpg",
+    });
+
+    const common = {
+      chatId: "123",
+      token: "tok",
+      runtime,
+      bot,
+      replyToMode: "off" as const,
+      textLimit: 4000,
+    };
+
+    await deliverReplies({
+      ...common,
+      replies: [{ mediaUrl: "/tmp/screenshot.png" }],
+    });
+    await deliverReplies({
+      ...common,
+      replies: [{ mediaUrl: "file:///tmp/screenshot.png" }],
+    });
+
+    expect(loadWebMedia).toHaveBeenCalledTimes(1);
+    expect(sendPhoto).toHaveBeenCalledTimes(1);
+  });
+
   it("passes mediaLocalRoots to media loading", async () => {
     const runtime = { error: vi.fn(), log: vi.fn() };
     const sendPhoto = vi.fn().mockResolvedValue({
diff --git a/src/telegram/bot/delivery.ts b/src/telegram/bot/delivery.ts
index e4a7445..ce07416 100644
--- a/src/telegram/bot/delivery.ts
+++ b/src/telegram/bot/delivery.ts
@@ -33,6 +33,98 @@ import {
 const PARSE_ERR_RE = /can't parse entities|parse entities|find end of the entity/i;
 const VOICE_FORBIDDEN_RE = /VOICE_MESSAGES_FORBIDDEN/;
 const PHOTO_INVALID_DIMENSIONS_RE = /PHOTO_INVALID_DIMENSIONS/;
+const DELIVERY_MEDIA_DEDUPE_TTL_MS = 30 * 1000;
+const recentDeliveredMediaByScope = new Map<string, Map<string, number>>();
+
+function normalizeMediaUrlForDedupe(mediaUrl: string): string {
+  const trimmed = mediaUrl.trim();
+  if (!trimmed) {
+    return "";
+  }
+  try {
+    const parsed = new URL(trimmed);
+    if (parsed.protocol === "file:") {
+      return decodeURIComponent(parsed.pathname || trimmed);
+    }
+    parsed.hash = "";
+    return parsed.toString();
+  } catch {
+    return trimmed;
+  }
+}
+
+function dedupeMediaUrlsForDelivery(mediaUrls: string[], seenMediaKeys: Set<string>): string[] {
+  const deduped: string[] = [];
+  for (const raw of mediaUrls) {
+    if (typeof raw !== "string") {
+      continue;
+    }
+    const trimmed = raw.trim();
+    if (!trimmed) {
+      continue;
+    }
+    const dedupeKey = normalizeMediaUrlForDedupe(trimmed);
+    if (!dedupeKey || seenMediaKeys.has(dedupeKey)) {
+      continue;
+    }
+    seenMediaKeys.add(dedupeKey);
+    deduped.push(trimmed);
+  }
+  return deduped;
+}
+
+function buildDeliveryMediaScopeKey(
+  chatId: string,
+  replyToId: number | undefined,
+  thread?: TelegramThreadSpec | null,
+): string {
+  const threadPart =
+    thread && typeof thread.id === "number" && Number.isFinite(thread.id)
+      ? String(thread.id)
+      : "no-thread";
+  const replyPart = replyToId ? String(replyToId) : "no-reply";
+  return `${chatId}:${threadPart}:${replyPart}`;
+}
+
+function pruneExpiredMediaScope(scopeKey: string, now = Date.now()): Map<string, number> | null {
+  const scope = recentDeliveredMediaByScope.get(scopeKey);
+  if (!scope) {
+    return null;
+  }
+  for (const [mediaKey, expiresAt] of scope.entries()) {
+    if (expiresAt <= now) {
+      scope.delete(mediaKey);
+    }
+  }
+  if (scope.size === 0) {
+    recentDeliveredMediaByScope.delete(scopeKey);
+    return null;
+  }
+  return scope;
+}
+
+function hasRecentDeliveredMedia(scopeKey: string | null, mediaKey: string, now = Date.now()): boolean {
+  if (!scopeKey) {
+    return false;
+  }
+  const scope = pruneExpiredMediaScope(scopeKey, now);
+  return scope ? scope.has(mediaKey) : false;
+}
+
+function markRecentDeliveredMedia(scopeKey: string | null, mediaKey: string, now = Date.now()): void {
+  if (!scopeKey) {
+    return;
+  }
+  const scope = pruneExpiredMediaScope(scopeKey, now) ?? new Map<string, number>();
+  scope.set(mediaKey, now + DELIVERY_MEDIA_DEDUPE_TTL_MS);
+  recentDeliveredMediaByScope.set(scopeKey, scope);
+}
+
+export function __resetDeliveryMediaDedupeForTests(): void {
+  recentDeliveredMediaByScope.clear();
+}
 
 export async function deliverReplies(params: {
   replies: ReplyPayload[];
@@ -67,6 +159,7 @@ export async function deliverReplies(params: {
   const chunkMode = params.chunkMode ?? "length";
   let hasReplied = false;
   let hasDelivered = false;
+  const deliveredMediaKeys = new Set<string>();
   const markDelivered = () => {
     hasDelivered = true;
   };
@@ -91,22 +184,29 @@ export async function deliverReplies(params: {
     }
     return chunks;
   };
+
   for (const reply of replies) {
-    const hasMedia = Boolean(reply?.mediaUrl) || (reply?.mediaUrls?.length ?? 0) > 0;
+    const replyToId = replyToMode === "off" ? undefined : resolveTelegramReplyId(reply.replyToId);
+    const deliveryScopeKey = buildDeliveryMediaScopeKey(chatId, replyToId, thread);
+    const nowMs = Date.now();
+    const mediaListRaw = reply.mediaUrls?.length
+      ? reply.mediaUrls
+      : reply.mediaUrl
+        ? [reply.mediaUrl]
+        : [];
+    const mediaList = dedupeMediaUrlsForDelivery(mediaListRaw, deliveredMediaKeys).filter((mediaUrl) => {
+      const mediaKey = normalizeMediaUrlForDedupe(mediaUrl);
+      return !mediaKey || !hasRecentDeliveredMedia(deliveryScopeKey, mediaKey, nowMs);
+    });
+    const hasMedia = mediaList.length > 0;
     if (!reply?.text && !hasMedia) {
-      if (reply?.audioAsVoice) {
+      if (reply?.audioAsVoice || mediaListRaw.length > 0) {
         logVerbose("telegram reply has audioAsVoice without media/text; skipping");
         continue;
       }
       runtime.error?.(danger("reply missing text/media"));
       continue;
     }
-    const replyToId = replyToMode === "off" ? undefined : resolveTelegramReplyId(reply.replyToId);
-    const mediaList = reply.mediaUrls?.length
-      ? reply.mediaUrls
-      : reply.mediaUrl
-        ? [reply.mediaUrl]
-        : [];
     const telegramData = reply.channelData?.telegram as
       | { buttons?: Array<Array<{ text: string; callback_data: string }>> }
       | undefined;
@@ -143,6 +243,7 @@ export async function deliverReplies(params: {
     // (when caption exceeds Telegram's 1024-char limit)
     let pendingFollowUpText: string | undefined;
     for (const mediaUrl of mediaList) {
+      const mediaDedupeKey = normalizeMediaUrlForDedupe(mediaUrl);
       const isFirstMedia = first;
       const media = await loadWebMedia(mediaUrl, {
         localRoots: params.mediaLocalRoots,
@@ -177,6 +278,7 @@ export async function deliverReplies(params: {
           thread,
         }),
       };
+      let mediaSent = false;
       if (isGif) {
         await withTelegramApiErrorLogging({
           operation: "sendAnimation",
@@ -184,6 +286,7 @@ export async function deliverReplies(params: {
           fn: () => bot.api.sendAnimation(chatId, file, { ...mediaParams }),
         });
         markDelivered();
+        mediaSent = true;
       } else if (kind === "image") {
         try {
           await withTelegramApiErrorLogging({
@@ -192,6 +295,7 @@ export async function deliverReplies(params: {
             fn: () => bot.api.sendPhoto(chatId, file, { ...mediaParams }),
           });
           markDelivered();
+          mediaSent = true;
         } catch (photoErr) {
           if (!isPhotoInvalidDimensions(photoErr)) {
             throw photoErr;
@@ -205,6 +309,7 @@ export async function deliverReplies(params: {
             fn: () => bot.api.sendDocument(chatId, file, { ...mediaParams }),
           });
           markDelivered();
+          mediaSent = true;
         }
       } else if (kind === "video") {
         await withTelegramApiErrorLogging({
@@ -213,6 +318,7 @@ export async function deliverReplies(params: {
           fn: () => bot.api.sendVideo(chatId, file, { ...mediaParams }),
         });
         markDelivered();
+        mediaSent = true;
       } else if (kind === "audio") {
         const { useVoice } = resolveTelegramVoiceSend({
           wantsVoice: reply.audioAsVoice === true, // default false (backward compatible)
@@ -232,6 +338,7 @@ export async function deliverReplies(params: {
               fn: () => bot.api.sendVoice(chatId, file, { ...mediaParams }),
             });
             markDelivered();
+            mediaSent = true;
           } catch (voiceErr) {
             // Fall back to text if voice messages are forbidden in this chat.
             // This happens when the recipient has Telegram Premium privacy settings
@@ -272,6 +379,7 @@ export async function deliverReplies(params: {
             fn: () => bot.api.sendAudio(chatId, file, { ...mediaParams }),
           });
           markDelivered();
+          mediaSent = true;
         }
       } else {
         await withTelegramApiErrorLogging({
@@ -280,6 +388,10 @@ export async function deliverReplies(params: {
           fn: () => bot.api.sendDocument(chatId, file, { ...mediaParams }),
         });
         markDelivered();
+        mediaSent = true;
+      }
+      if (mediaSent && mediaDedupeKey) {
+        markRecentDeliveredMedia(deliveryScopeKey, mediaDedupeKey, nowMs);
       }
       if (replyToId && !hasReplied) {
         hasReplied = true;
